<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and functions · SequentialMonteCarlo.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SequentialMonteCarlo.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Contents</a></li><li><a class="toctext" href="../intro/">Introduction</a></li><li><a class="toctext" href="../smcintegrals/">SMC integrals</a></li><li><a class="toctext" href="../smcalgorithm/">SMC algorithm</a></li><li><a class="toctext" href="../smctheory/">Theoretical properties</a></li><li><a class="toctext" href="../smcve/">Variance estimators</a></li><li><a class="toctext" href="../smcadaptive/">Adaptive resampling</a></li><li><a class="toctext" href="../csmc/">Conditional SMC</a></li><li><a class="toctext" href="../impl/">Implementation notes</a></li><li><a class="toctext" href="../performance/">Performance tips</a></li><li><a class="toctext" href="../smcinterface/">SMC interface</a></li><li class="current"><a class="toctext" href>Types and functions</a><ul class="internal"><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li></ul></li><li><a class="toctext" href="../hmm/">Hidden Markov models</a></li><li><a class="toctext" href="../bench/">Benchmarks</a></li><li><a class="toctext" href="../refs/">References</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Types and functions</a></li></ul><a class="edit-page" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/master/docs/src/guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Types and functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Documentation-strings-1" href="#Documentation-strings-1">Documentation strings</a></h1><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.SMCModel" href="#SequentialMonteCarlo.SMCModel"><code>SequentialMonteCarlo.SMCModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SMCModel(M!::F1, lG::F2, maxn::Int64, particle::Type, pScratch::Type) where
  {F1&lt;:Function,F2&lt;:Function}</code></pre><ul><li><code>M!</code> Mutation function</li><li><code>lG</code> Log potential function</li><li><code>maxn</code> Maximum n for which the model is well-defined</li><li><code>particle</code> Type of a particle</li><li><code>pScratch</code> Type of particle scratch space</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/structures.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.SMCIO" href="#SequentialMonteCarlo.SMCIO"><code>SequentialMonteCarlo.SMCIO</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SMCIO{Particle, ParticleScratch}</code></pre><p>Structs of this type should be constructed using the provided constructor. Important fields:</p><ul><li><code>N::Int64</code> Number of particles <span>$N$</span></li><li><code>n::Int64</code> Number of steps <span>$n$</span></li><li><code>nthreads::Int64</code> Number of threads</li><li><code>fullOutput::Bool</code> Whether particle system history should be recorded</li><li><code>essThreshold::Float64</code> Relative ESS Threshold <span>$\tau$</span></li><li><code>zetas::Vector{Particle}</code> Time n particles <span>$\zeta_n^1, \ldots, \zeta_n^N$</span></li><li><code>eves::Vector{Int64}</code> Time n Eve indices <span>$E_n^1, \ldots, E_n^N$</span></li><li><code>ws::Vector{Float64}</code> Time n weights <span>$W_n^1, \ldots, W_n^N$</span></li><li><code>logZhats::Vector{Float64}</code> <span>$\log(\hat{Z}^N_1), \ldots, \log(\hat{Z}^N_n)$</span></li><li><code>Vhat1s::Vector{Float64}</code> <span>$\hat{V}_1^N(1), \ldots, \hat{V}_n^N(1)$</span></li><li><code>esses::Vector{Float64}</code> Relative ESS values <span>$\mathcal{E}_1^N, \ldots, \mathcal{E}_n^N$</span></li><li><code>resample::Vector{Bool}</code> Resampling indicators <span>$R_1, \ldots, R_{n-1}$</span></li></ul><p>Populated only if <code>fullOutput == true</code></p><ul><li><code>allZetas::Vector{Vector{Particle}}</code> All the particles</li><li><code>allWs::Vector{Vector{Float64}}</code> All the weights</li><li><code>allAs::Vector{Vector{Int64}}</code> All the ancestor indices</li><li><code>allEves::Vector{Vector{Int64}}</code> All the Eve indices</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/structures.jl#L225-L246">source</a></section><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.smc!-Tuple{SMCModel,SMCIO}" href="#SequentialMonteCarlo.smc!-Tuple{SMCModel,SMCIO}"><code>SequentialMonteCarlo.smc!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">smc!(model::SMCModel, smcio::SMCIO)</code></pre><p>Run the SMC algorithm for the given model and input/output arguments.</p><p>If <code>smcio.nthreads == 1</code> the algorithm will run in serial.</p></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/interface.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.csmc!-Union{Tuple{Particle}, Tuple{SMCModel,SMCIO{Particle,ParticleScratch} where ParticleScratch,Array{Particle,1},Array{Particle,1}}} where Particle" href="#SequentialMonteCarlo.csmc!-Union{Tuple{Particle}, Tuple{SMCModel,SMCIO{Particle,ParticleScratch} where ParticleScratch,Array{Particle,1},Array{Particle,1}}} where Particle"><code>SequentialMonteCarlo.csmc!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">csmc!(model::SMCModel, smcio::SMCIO, ref::Vector{Particle}, refout::Vector{Particle})</code></pre><p>Run the conditional SMC algorithm for the given model, input/output arguments, reference path and output path.</p><p>It is permitted for ref and refout to be the same. If <code>smcio.nthreads == 1</code> the algorithm will run in serial.</p></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/interface.jl#L15-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.SMCIO-Union{Tuple{Int64,Int64,Int64,Bool}, Tuple{Int64,Int64,Int64,Bool,Float64}, Tuple{ParticleScratch}, Tuple{Particle}} where ParticleScratch where Particle" href="#SequentialMonteCarlo.SMCIO-Union{Tuple{Int64,Int64,Int64,Bool}, Tuple{Int64,Int64,Int64,Bool,Float64}, Tuple{ParticleScratch}, Tuple{Particle}} where ParticleScratch where Particle"><code>SequentialMonteCarlo.SMCIO</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SMCIO{Particle, ParticleScratch}(N::Int64, n::Int64, nthreads::Int64,
  fullOutput::Bool, essThreshold::Float64 = 2.0) where
  {Particle, ParticleScratch}</code></pre><p>Constructor for <code>SMCIO</code> structs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/structures.jl#L270-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.eta-Union{Tuple{F}, Tuple{Particle}, Tuple{SMCIO{Particle,ParticleScratch} where ParticleScratch,F,Bool,Int64}} where F&lt;:Function where Particle" href="#SequentialMonteCarlo.eta-Union{Tuple{F}, Tuple{Particle}, Tuple{SMCIO{Particle,ParticleScratch} where ParticleScratch,F,Bool,Int64}} where F&lt;:Function where Particle"><code>SequentialMonteCarlo.eta</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">eta(smcio::SMCIO{Particle}, f::F, hat::Bool, p::Int64) where {Particle, F&lt;:Function}</code></pre><p>Compute:</p><ul><li><code>!hat</code>: <span>$\eta^N_p(f)$</span></li><li><code>hat</code>:  <span>$\hat{\eta}_p^N(f)$</span></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/interface.jl#L57-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.allEtas-Union{Tuple{F}, Tuple{SMCIO,F,Bool}} where F&lt;:Function" href="#SequentialMonteCarlo.allEtas-Union{Tuple{F}, Tuple{SMCIO,F,Bool}} where F&lt;:Function"><code>SequentialMonteCarlo.allEtas</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">allEtas(smcio::SMCIO, f::F, hat::Bool) where F&lt;:Function</code></pre><p>Compute <code>eta(smcio::SMCIO, f::F, hat::Bool, p)</code> for p in {1, …, smcio.n}</p></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/interface.jl#L75-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.slgamma-Union{Tuple{F}, Tuple{SMCIO,F,Bool,Int64}} where F&lt;:Function" href="#SequentialMonteCarlo.slgamma-Union{Tuple{F}, Tuple{SMCIO,F,Bool,Int64}} where F&lt;:Function"><code>SequentialMonteCarlo.slgamma</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">slgamma(smcio::SMCIO, f::F, hat::Bool, p::Int64) where {Particle, F&lt;:Function}</code></pre><p>Compute:</p><ul><li><code>!hat</code>: <span>$(\eta^N_p(f) \geq 0, \log |\gamma^N_p(f)|)$</span></li><li><code>hat</code>:  <span>$(\hat{\eta}^N_p(f) \geq 0, \log |\hat{\gamma}_p^N(f)|)$</span></li></ul><p>The result is returned as a <code>Tuple{Bool, Float64}</code>: the first component represents whether the returned value is non-negative, the second is the logarithm of the absolute value of the approximation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/interface.jl#L89-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.allGammas-Union{Tuple{F}, Tuple{SMCIO,F,Bool}} where F&lt;:Function" href="#SequentialMonteCarlo.allGammas-Union{Tuple{F}, Tuple{SMCIO,F,Bool}} where F&lt;:Function"><code>SequentialMonteCarlo.allGammas</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">allGammas(smcio::SMCIO, f::F, hat::Bool) where F&lt;:Function</code></pre><p>Compute <code>slgamma(smcio::SMCIO, f::F, hat::Bool, p)</code> for p in {1, …, smcio.n}</p></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/interface.jl#L109-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.V-Union{Tuple{F}, Tuple{Particle}, Tuple{SMCIO{Particle,ParticleScratch} where ParticleScratch,F,Bool,Bool,Int64}} where F&lt;:Function where Particle" href="#SequentialMonteCarlo.V-Union{Tuple{F}, Tuple{Particle}, Tuple{SMCIO{Particle,ParticleScratch} where ParticleScratch,F,Bool,Bool,Int64}} where F&lt;:Function where Particle"><code>SequentialMonteCarlo.V</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">V(smcio::SMCIO{Particle}, f::F, hat::Bool, centred::Bool, p::Int64) where
  {Particle, F&lt;:Function}</code></pre><p>Compute:</p><ul><li><code>!hat &amp; !centred</code>: <span>$V^N_p(f)$</span></li><li><code>!hat &amp; centred</code>: <span>$V^N_p(f-\eta_p^N(f))$</span></li><li><code>hat &amp; !centred</code>: <span>$\hat{V}_p^N(f)$</span></li><li><code>hat &amp; centred</code>:  <span>$\hat{V}_p^N(f-\hat{\eta}_p^N(f))$</span></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/interface.jl#L132-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.vpns-Union{Tuple{F}, Tuple{SMCIO,F,Bool,Bool,Int64}} where F&lt;:Function" href="#SequentialMonteCarlo.vpns-Union{Tuple{F}, Tuple{SMCIO,F,Bool,Bool,Int64}} where F&lt;:Function"><code>SequentialMonteCarlo.vpns</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vpns(smcio::SMCIO, f::F, hat::Bool, centred::Bool, n::Int64) where F&lt;:Function</code></pre><p>Compute a vector of the values of, for p = 1, …, n,</p><ul><li><code>!hat &amp; !centred</code>: <span>$v^N_{p,n}(f)$</span></li><li><code>!hat &amp; centred</code>:  <span>$v^N_{p,n}(f-\eta_n^N(f))$</span></li><li><code>hat &amp; !centred</code>:  <span>$\hat{v}_{p,n}^N(f)$</span></li><li><code>hat &amp; centred</code>:   <span>$\hat{v}_{p,n}^N(f-\hat{\eta}_n^N(f))$</span></li></ul><p>Note: if <code>essThreshold &lt;= 1.0</code>, and resampling did not occur at every time, the length of the output will be less than n.</p></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/interface.jl#L176-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SequentialMonteCarlo.v-Union{Tuple{F}, Tuple{SMCIO,F,Bool,Bool,Int64}} where F&lt;:Function" href="#SequentialMonteCarlo.v-Union{Tuple{F}, Tuple{SMCIO,F,Bool,Bool,Int64}} where F&lt;:Function"><code>SequentialMonteCarlo.v</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">v(smcio::SMCIO, f::F, hat::Bool, centred::Bool, n::Int64) where F&lt;:Function</code></pre><p>Compute:</p><ul><li><code>!hat &amp; !centred</code>: <span>$v^N_n(f)$</span></li><li><code>!hat &amp; centred</code>: <span>$v^N_n(f-\eta_n^N(f))$</span></li><li><code>hat &amp; !centred</code>: <span>$\hat{v}_n^N(f)$</span></li><li><code>hat &amp; centred</code>:  <span>$\hat{v}_n^N(f-\hat{\eta}_n^N(f))$</span></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/c1b7ae093f55c3f204e87bf77a22a27cd344fb9c/src/interface.jl#L285-L293">source</a></section><footer><hr/><a class="previous" href="../smcinterface/"><span class="direction">Previous</span><span class="title">SMC interface</span></a><a class="next" href="../hmm/"><span class="direction">Next</span><span class="title">Hidden Markov models</span></a></footer></article></body></html>
