<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SMC algorithm · SequentialMonteCarlo.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SequentialMonteCarlo.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Contents</a></li><li><a class="toctext" href="../intro/">Introduction</a></li><li><a class="toctext" href="../smcintegrals/">SMC integrals</a></li><li class="current"><a class="toctext" href>SMC algorithm</a><ul class="internal"><li><a class="toctext" href="#basicsmc-1">SMC algorithm</a></li><li><a class="toctext" href="#mainapprox-1">Main particle approximations</a></li><li><a class="toctext" href="#Genealogical-structure-1">Genealogical structure</a></li><li><a class="toctext" href="#Recursive-definition-1">Recursive definition</a></li></ul></li><li><a class="toctext" href="../smctheory/">Theoretical properties</a></li><li><a class="toctext" href="../smcve/">Variance estimators</a></li><li><a class="toctext" href="../smcadaptive/">Adaptive resampling</a></li><li><a class="toctext" href="../csmc/">Conditional SMC</a></li><li><a class="toctext" href="../impl/">Implementation notes</a></li><li><a class="toctext" href="../performance/">Performance tips</a></li><li><a class="toctext" href="../smcinterface/">SMC interface</a></li><li><a class="toctext" href="../guide/">Types and functions</a></li><li><a class="toctext" href="../hmm/">Hidden Markov models</a></li><li><a class="toctext" href="../bench/">Benchmarks</a></li><li><a class="toctext" href="../refs/">References</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>SMC algorithm</a></li></ul><a class="edit-page" href="https://github.com/awllee/SequentialMonteCarlo.jl/blob/master/docs/src/smcalgorithm.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>SMC algorithm</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="SMC-algorithm-and-particle-approximations-1" href="#SMC-algorithm-and-particle-approximations-1">SMC algorithm and particle approximations</a></h1><h2><a class="nav-anchor" id="basicsmc-1" href="#basicsmc-1">SMC algorithm</a></h2><p>The implemented algorithm is as follows. The random variables <span>$\zeta_p^1, \ldots, \zeta_p^N$</span> are typically referred to as particles, and the approximations they define are referred to as particle approximations.</p><hr/><ol><li><p>Sample <span>$\zeta_1^i \overset{\mathrm{i.i.d.}}{\sim} M_1$</span> for <span>$i \in \{1,\ldots,N\}$</span>.</p></li><li><p>For <span>$p=2,\ldots,n$</span>:</p><ul><li><p>sample a vector <span>$A_{p-1}^1,\ldots,A_{p-1}^N$</span> of i.i.d. <span>${\rm Categorical}(G_{p-1}(\zeta_{p-1}^1),\ldots,G_{p-1}(\zeta_{p-1}^N))$</span> random variables in increasing order.</p></li><li><p>sample <span>$\zeta_p^i \overset{\mathrm{ind}} {\sim} M_p(\zeta_{p-1}^{A_{p-1}^i}, \cdot)$</span> for <span>$i \in \{1,\ldots,N\}$</span>.</p></li></ul></li></ol><hr/><p>This algorithm is referred to as SMC with multinomial resampling because the vector of numbers of <em>offspring</em> of the time <span>$p-1$</span> particles follows a multinomial distribution.</p><h2><a class="nav-anchor" id="mainapprox-1" href="#mainapprox-1">Main particle approximations</a></h2><p>For some <span>$p \in \{1,\ldots,n\}$</span>, the particle approximation of <span>$\eta_p(f)$</span> is obtained by constructing a particle approximation <span>$\eta_p^N$</span> of <span>$\eta_p$</span> and then calculating <span>$\eta_p^N(f)$</span>. Specifically, we define</p><div>\[\eta_p^N := \frac{1}{N} \sum_{i=1}^N \delta_{\zeta_p^i}, \qquad p \in \{1,\ldots,n\}\]</div><p>and the particle approximation of <span>$\eta_p(f)$</span> is then simply</p><div>\[\eta_p^N(f) = \int f(x) \eta_p^N({\rm d}x) = \frac{1}{N} \sum_{i=1}^N f(\zeta_p^i).\]</div><p>Similarly, we define</p><div>\[\hat{\eta}_p^N:= \frac{\eta_p^N \cdot G_p}{\eta_p^N(G_p)}, \qquad p \in \{1, \ldots, n\}\]</div><p>so that the particle approximation of <span>$\hat{\eta}_p(f)$</span> is</p><div>\[\hat{\eta}^N_p(f) = \int f(x) \hat{\eta}_p^N({\rm d}x) \frac{\sum_{i=1}^N G_p(\zeta_p^i) f(\zeta_p^i)}{\sum_{i=1}^N G_p(\zeta_p^i)}.\]</div><p>Finally, the particle approximations of <span>$\hat{Z}_1,\ldots,\hat{Z}_n$</span> are defined by <span>$\hat{Z}_1^N:=\eta_1^N(G_1)$</span> and for <span>$p \in \{2,\ldots,n\}$</span>, <span>$\hat{Z}_p^N:=\hat{Z}_{p-1}^N\eta_p^N(G_p)$</span>.</p><h2><a class="nav-anchor" id="Genealogical-structure-1" href="#Genealogical-structure-1">Genealogical structure</a></h2><p>The particle system defined by the SMC algorithm has a genealogical structure, induced by the ancestor indices. We define Eve indices such that <span>$E_p^i$</span> is the index of the time <span>$1$</span> ancestor of <span>$\zeta_p^i$</span>. That is, the Eve indices satisfy <span>$E_1^i := i$</span> for <span>$i \in \{1, \ldots, N\}$</span> and</p><div>\[E_p^i = E_{p-1}^{A_{p-1}^i}, \qquad p \in \{2, \ldots, n\}, \quad i \in \{1, \ldots, N\}.\]</div><p>These can be used to quantify and visualize the path degeneracy phenomenon associated with the SMC algorithm. Since the ancestor indices are in sorted order, so too are the Eve indices at each time.</p><h2><a class="nav-anchor" id="Recursive-definition-1" href="#Recursive-definition-1">Recursive definition</a></h2><p>The SMC algorithm is intimately connected to the <a href="../smcintegrals/#recursivedefmeasures-1">recursive definition of the SMC measures</a> themselves.</p><p>Let us define the sampling operator <span>$S^N$</span> to be the random map that takes a measure <span>$\mu$</span> and outputs a random measure</p><div>\[\mu^N = S^N \mu = \frac{1}{N} \sum_{i=1}^N \delta_{X^i}, \qquad \text{where } X^i \overset{\mathrm{i.i.d.}}{\sim} \mu.\]</div><p>Then we have</p><div>\[\eta^N_1 = S^N M_1, \qquad \hat{\eta}_1^N = \frac {\eta^N_1 \cdot G_1} {\eta^N_1(G_1)},\]</div><p>and for <span>$p = 2, \ldots, n$</span>,</p><div>\[\eta^N_p = S^N (\hat{\eta}_{p-1}^N M_p), \qquad \hat{\eta}_p^N = \frac {\eta^N_p \cdot G_p} {\eta^N_p(G_p)}.\]</div><p>This mirrors almost exactly the recursive definitions for the SMC measures, where one has instead</p><div>\[\eta_1 = M_1, \qquad \hat{\eta}_1 = \frac {\eta_1 \cdot G_1} {\eta_1(G_1)},\]</div><p>and for <span>$p = 2, \ldots, n$</span>,</p><div>\[\eta_p = \hat{\eta}_{p-1} M_p, \qquad \hat{\eta}_p = \frac {\eta_p \cdot G_p} {\eta_p(G_p)}.\]</div><p>We notice also that <span>$\hat{Z}^N_p = \hat{Z}^N_{p-1} \eta^N_p(G_p)$</span> while <span>$\hat{Z}_p = \hat{Z}_{p-1} \eta_p(G_p)$</span> for <span>$p \in \{2, \ldots, n\}$</span>.</p><footer><hr/><a class="previous" href="../smcintegrals/"><span class="direction">Previous</span><span class="title">SMC integrals</span></a><a class="next" href="../smctheory/"><span class="direction">Next</span><span class="title">Theoretical properties</span></a></footer></article></body></html>
